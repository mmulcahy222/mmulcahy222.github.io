{
  "version": 3,
  "sources": ["../../three/src/renderers/common/Sampler.js", "../../three/src/renderers/common/nodes/NodeSampler.js", "../../three/src/renderers/common/StorageBuffer.js", "../../three/src/renderers/common/nodes/NodeStorageBuffer.js", "../../three/src/renderers/webgpu/utils/WebGPUConstants.js", "../../three/src/renderers/webgpu/utils/WebGPUTextureUtils.js", "../../three/src/renderers/webgpu/nodes/WGSLNodeFunction.js", "../../three/src/renderers/webgpu/nodes/WGSLNodeParser.js", "../../three/src/renderers/webgpu/nodes/WGSLNodeBuilder.js"],
  "sourcesContent": ["import Binding from './Binding.js';\n\n/**\n * Represents a sampler binding type.\n *\n * @private\n * @augments Binding\n */\nclass Sampler extends Binding {\n\n\t/**\n\t * Constructs a new sampler.\n\t *\n\t * @param {string} name - The samplers's name.\n\t * @param {?Texture} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The texture the sampler is referring to.\n\t\t *\n\t\t * @type {?Texture}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampler = true;\n\n\t}\n\n}\n\nexport default Sampler;\n", "import Sampler from '../Sampler.js';\n\n/**\n * A special form of sampler binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments Sampler\n */\nclass NodeSampler extends Sampler {\n\n\t/**\n\t * Constructs a new node-based sampler.\n\t *\n\t * @param {string} name - The samplers's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * Updates the texture value of this sampler.\n\t */\n\tupdate() {\n\n\t\tthis.texture = this.textureNode.value;\n\n\t}\n\n}\n\nexport default NodeSampler;\n", "import Buffer from './Buffer.js';\n\n/**\n * Represents a storage buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass StorageBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {string} name - The buffer's name.\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {BufferAttribute}\n\t\t */\n\t\tthis.attribute = attribute;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nexport default StorageBuffer;\n", "import StorageBuffer from '../StorageBuffer.js';\nimport { NodeAccess } from '../../../nodes/core/constants.js';\n\nlet _id = 0;\n\n/**\n * A special form of storage buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments StorageBuffer\n */\nclass NodeStorageBuffer extends StorageBuffer {\n\n\t/**\n\t * Constructs a new node-based storage buffer.\n\t *\n\t * @param {StorageBufferNode} nodeUniform - The storage buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {StorageBufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The storage buffer.\n\t *\n\t * @type {BufferAttribute}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nexport default NodeStorageBuffer;\n", "export const GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nexport const GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nexport const GPUStoreOp = {\n\tStore: 'store',\n\tDiscard: 'discard'\n};\n\nexport const GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nexport const GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nexport const GPUCullMode = {\n\tNone: 'none',\n\tFront: 'front',\n\tBack: 'back'\n};\n\nexport const GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nexport const GPUVertexFormat = {\n\tUint8x2: 'uint8x2',\n\tUint8x4: 'uint8x4',\n\tSint8x2: 'sint8x2',\n\tSint8x4: 'sint8x4',\n\tUnorm8x2: 'unorm8x2',\n\tUnorm8x4: 'unorm8x4',\n\tSnorm8x2: 'snorm8x2',\n\tSnorm8x4: 'snorm8x4',\n\tUint16x2: 'uint16x2',\n\tUint16x4: 'uint16x4',\n\tSint16x2: 'sint16x2',\n\tSint16x4: 'sint16x4',\n\tUnorm16x2: 'unorm16x2',\n\tUnorm16x4: 'unorm16x4',\n\tSnorm16x2: 'snorm16x2',\n\tSnorm16x4: 'snorm16x4',\n\tFloat16x2: 'float16x2',\n\tFloat16x4: 'float16x4',\n\tFloat32: 'float32',\n\tFloat32x2: 'float32x2',\n\tFloat32x3: 'float32x3',\n\tFloat32x4: 'float32x4',\n\tUint32: 'uint32',\n\tUint32x2: 'uint32x2',\n\tUint32x3: 'uint32x3',\n\tUint32x4: 'uint32x4',\n\tSint32: 'sint32',\n\tSint32x2: 'sint32x2',\n\tSint32x3: 'sint32x3',\n\tSint32x4: 'sint32x4'\n};\n\nexport const GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10uFloat: 'rgb10a2unorm',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\t// Depth and stencil formats\n\n\tStencil8: 'stencil8',\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nexport const GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nexport const GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nexport const GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDstColor: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nexport const GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nexport const GPUColorWriteFlags = {\n\tNone: 0,\n\tRed: 0x1,\n\tGreen: 0x2,\n\tBlue: 0x4,\n\tAlpha: 0x8,\n\tAll: 0xF\n};\n\nexport const GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nexport const GPUBufferBindingType = {\n\tUniform: 'uniform',\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nexport const GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nexport const GPUSamplerBindingType = {\n\tFiltering: 'filtering',\n\tNonFiltering: 'non-filtering',\n\tComparison: 'comparison'\n};\n\nexport const GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nexport const GPUTextureDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nexport const GPUTextureViewDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tCubeArray: 'cube-array',\n\tThreeD: '3d'\n};\n\nexport const GPUTextureAspect = {\n\tAll: 'all',\n\tStencilOnly: 'stencil-only',\n\tDepthOnly: 'depth-only'\n};\n\nexport const GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nexport const GPUFeatureName = {\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups'\n};\n", "import {\n\tGPUTextureFormat, GPUAddressMode, GPUFilterMode, GPUTextureDimension, GPUFeatureName\n} from './WebGPUConstants.js';\n\nimport WebGPUTexturePassUtils from './WebGPUTexturePassUtils.js';\n\nimport {\n\tByteType, ShortType,\n\tNearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter,\n\tRepeatWrapping, MirroredRepeatWrapping,\n\tRGB_ETC2_Format, RGBA_ETC2_EAC_Format,\n\tRGBAFormat, RGBFormat, RedFormat, RGFormat, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, UnsignedByteType, FloatType, HalfFloatType, SRGBColorSpace, DepthFormat, DepthStencilFormat,\n\tRGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format,\n\tRGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, UnsignedIntType, UnsignedShortType, UnsignedInt248Type, UnsignedInt5999Type,\n\tNeverCompare, AlwaysCompare, LessCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, IntType, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat,\n\tCubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping\n} from '../../../constants.js';\nimport { CubeTexture } from '../../../textures/CubeTexture.js';\nimport { DepthTexture } from '../../../textures/DepthTexture.js';\nimport { Texture } from '../../../textures/Texture.js';\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\n/**\n * A WebGPU backend utility module for managing textures.\n *\n * @private\n */\nclass WebGPUTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the pass utils.\n\t\t *\n\t\t * @type {?WebGPUTexturePassUtils}\n\t\t * @default null\n\t\t */\n\t\tthis._passUtils = null;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,Texture>}\n\t\t */\n\t\tthis.defaultTexture = {};\n\n\t\t/**\n\t\t * A dictionary for managing default cube textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,CubeTexture>}\n\t\t */\n\t\tthis.defaultCubeTexture = {};\n\n\t\t/**\n\t\t * A default video frame.\n\t\t *\n\t\t * @type {?VideoFrame}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultVideoFrame = null;\n\n\t\t/**\n\t\t * Represents the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {?GPUTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * Represents the depth attachment of the default framebuffer.\n\t\t *\n\t\t * @type {DepthTexture}\n\t\t */\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tthis.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tconst { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySamples,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\tthis.createDefaultTexture( texture );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( isMSAA ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = samples;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the color buffer representing the color\n\t * attachment of the default framebuffer.\n\t *\n\t * @return {GPUTexture} The color buffer.\n\t */\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\t/**\n\t * Returns the depth buffer representing the depth\n\t * attachment of the default framebuffer.\n\t *\n\t * @param {boolean} [depth=true] - Whether depth is enabled or not.\n\t * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.\n\t * @return {GPUTexture} The depth buffer.\n\t */\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is an environment map.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the given texture is an environment map or not.\n\t */\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t/**\n\t * Returns the default GPU texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default GPU cube texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default video frame used as default data in context of video textures.\n\t *\n\t * @private\n\t * @return {VideoFrame} The video frame.\n\t */\n\t_getDefaultVideoFrame() {\n\n\t\tlet defaultVideoFrame = this.defaultVideoFrame;\n\n\t\tif ( defaultVideoFrame === null ) {\n\n\t\t\tconst init = {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tcodedWidth: 1,\n\t\t\t\tcodedHeight: 1,\n\t\t\t\tformat: 'RGBA',\n\t\t\t};\n\n\t\t\tthis.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );\n\n\t\t}\n\n\t\treturn defaultVideoFrame;\n\n\t}\n\n\t/**\n\t * Uploads cube texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array} images - The cube image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t */\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t */\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image,\n\t\t\t\tflipY: flipY\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns the pass utils singleton.\n\t *\n\t * @private\n\t * @return {WebGPUTexturePassUtils} The utils instance.\n\t */\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [originDepth=0] - The origin depth.\n\t */\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Object} image - An object defining the image buffer data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {number} [depth=0] - TODO.\n\t */\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads compressed texture data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array<Object>} mipmaps - An array with mipmap data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t */\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is only relevant for compressed texture formats. It returns a block\n\t * data descriptor for the given GPU compressed texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU compressed texture format.\n\t * @return {Object} The block data descriptor.\n\t */\n\t_getBlockData( format ) {\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t/**\n\t * Converts the three.js uv wrapping constants to GPU address mode constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a uv wrapping mode.\n\t * @return {string} The GPU address mode.\n\t */\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t/**\n\t * Converts the three.js filter constants to GPU filter constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a filter mode.\n\t * @return {string} The GPU filter mode.\n\t */\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t/**\n\t * Returns the GPU dimensions for the given texture.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The GPU dimension.\n\t */\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\n/**\n * Returns the GPU format for the given texture.\n *\n * @param {Texture} texture - The texture.\n * @param {?GPUDevice} [device=null] - The GPU device which is used for feature detection.\n * It is not necessary to apply the device for most formats.\n * @return {string} The GPU format.\n */\nexport function getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nexport default WebGPUTextureUtils;\n", "import NodeFunction from '../../../nodes/core/NodeFunction.js';\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\t'texture_depth_multisampled_2d': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new WGSL node function.\n\t *\n\t * @param {string} source - The WGSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\t/**\n\t * This method returns the WGSL code of the node function.\n\t *\n\t * @param {string} [name=this.name] - The function's name.\n\t * @return {string} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\nexport default WGSLNodeFunction;\n", "import NodeParser from '../../../nodes/core/NodeParser.js';\nimport WGSLNodeFunction from './WGSLNodeFunction.js';\n\n/**\n * A WGSL node parser.\n *\n * @augments NodeParser\n */\nclass WGSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given WGSL code an returns a node function.\n\t *\n\t * @param {string} source - The WGSL code.\n\t * @return {WGSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\nexport default WGSLNodeParser;\n", "import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';\n\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture, NodeSampledTexture3D } from '../../common/nodes/NodeSampledTexture.js';\n\nimport NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';\nimport NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';\n\nimport { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';\n\nimport { getFormat } from '../utils/WebGPUTextureUtils.js';\n\nimport WGSLNodeParser from './WGSLNodeParser.js';\nimport { NodeAccess } from '../../../nodes/core/constants.js';\n\nimport VarNode from '../../../nodes/core/VarNode.js';\nimport ExpressionNode from '../../../nodes/code/ExpressionNode.js';\n\nimport { NoColorSpace, FloatType, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter } from '../../../constants.js';\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n/**\n * A node builder targeting WGSL.\n *\n * This module generates WGSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new WGSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of builtins.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.builtins = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Set of directives.\n\t\t *\n\t\t * @type {Object<string,Set<string>>}\n\t\t */\n\t\tthis.directives = {};\n\n\t\t/**\n\t\t * A map for managing scope arrays. Only relevant for when using\n\t\t * {@link WorkgroupInfoNode} in context of compute shaders.\n\t\t *\n\t\t * @type {Map<string,Object>}\n\t\t */\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampled textures.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling video textures.\n\t *\n\t * @private\n\t * @param {string} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\t_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\t_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates a wrap function used in context of textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @return {string} The name of the generated function.\n\t */\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${texture.isData3DTexture ? '3d' : '2d'}T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\t// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n\t\t\tconst coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n\t\t\tlet code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\\n\\n\\treturn ${coordType}(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tcode += ',\\n';\n\t\t\t\taddWrapSnippet( texture.wrapR, 'z' );\n\n\t\t\t}\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn `array< ${ this.getType( type ) }, ${ count } >`;\n\n\t}\n\n\t/**\n\t * Generates a WGSL variable that holds the texture dimension of the given texture.\n\t * It also returns information about the the number of layers (elements) of an arrayed\n\t * texture as well as the cube face count of cube textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @param {string} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The name of the dimension variable.\n\t */\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\t\t\tlet dimensionType;\n\n\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\t\t\tconst isMultisampled = primarySamples > 1;\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tdimensionType = 'vec3<u32>';\n\n\t\t\t} else {\n\n\t\t\t\t// Regular 2D textures, depth textures, etc.\n\t\t\t\tdimensionType = 'vec2<u32>';\n\n\t\t\t}\n\n\t\t\t// Build parameters string based on texture type and multisampling\n\t\t\tif ( isMultisampled || texture.isVideoTexture || texture.isStorageTexture ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t\tif ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\t\ttextureData.arrayLayerCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode(\n\t\t\t\t\t\t`textureNumLayers(${textureProperty})`,\n\t\t\t\t\t\t'u32'\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// For cube textures, we know it's always 6 faces\n\t\t\tif ( texture.isTextureCube ) {\n\n\t\t\t\ttextureData.cubeFaceCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode( '6u', 'u32' )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a manual filtered texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.\n\t * Since it's a lookup, no sampling or filtering is applied.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n\t\tconst coordSnippet = `${vecType}<u32>(${wrapFunction}(${uvSnippet}) * ${vecType}<f32>(${textureDimension}))`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tif ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;\n\n\t\t} else if ( depthSnippet ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that writes a single texel to a texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {\n\n\t\treturn `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sampled values of the given texture should be compared against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.\n\t */\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is unfilterable.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the given texture is unfilterable or not.\n\t */\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\tthis.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a WGSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tif ( this.isCustomStruct( node ) ) {\n\n\t\t\t\t\treturn name;\n\n\t\t\t\t}\n\n\t\t\t\treturn name + '.value';\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name.\n\t *\n\t * @return {string} The name of the output struct.\n\t */\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t *\n\t * @param {string} op - The operator name to resolve.\n\t * @return {?string} The resolved operator name.\n\t */\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the node access for the given node and shader stage.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The node access.\n\t */\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' )\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\treturn node.access;\n\n\t}\n\n\t/**\n\t * Returns A WGSL snippet representing the storage access.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet representing the storage access.\n\t */\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${ uniformNode.name }_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t\tuniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\t/**\n\t * This method should be used whenever builtins are required in nodes.\n\t * The internal builtins data structure will make sure builtins are\n\t * defined in the WGSL source.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} property - The property name.\n\t * @param {string} type - The node data type.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given builtin is defined in the given shader stage.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {boolean} Whether the given builtin is defined in the given shader stage or not.\n\t */\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The WGSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup size builtin.\n\t *\n\t * @return {string} The subgroup size.\n\t */\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the invocation subgroup index builtin.\n\t *\n\t * @return {string} The invocation subgroup index.\n\t */\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup index builtin.\n\t *\n\t * @return {string} The subgroup index.\n\t */\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Overwritten as a NOP since this method is intended for the WebGL 2 backend.\n\t *\n\t * @return {null} Null.\n\t */\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `false` in context of WGSL.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Enables the given directive for the given shader stage.\n\t *\n\t * @param {string} name - The directive name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.\n\t */\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\t/**\n\t * Returns the directives of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that enables the directives of the given stage.\n\t */\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups' directive.\n\t */\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups-f16' directive.\n\t */\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'clip_distances' directive.\n\t */\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\t/**\n\t * Enables the 'f16' directive.\n\t */\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'dual_source_blending' directive.\n\t */\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\t/**\n\t * Returns the builtins of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that represents the builtins of the given stage.\n\t */\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * This method should be used when a new scoped buffer is used in context of\n\t * compute shaders. It adds the array to the internal data structure which is\n\t * later used to generate the respective WGSL.\n\t *\n\t * @param {string} name - The array name.\n\t * @param {string} scope - The scope.\n\t * @param {string} bufferType - The buffer type.\n\t * @param {string} bufferCount - The buffer count.\n\t * @return {string} The array name.\n\t */\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Returns the scoped arrays of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string|undefined} The WGSL snippet that defines the scoped arrays.\n\t * Returns `undefined` when used in the vertex or fragment stage.\n\t */\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'globalId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a WGSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The WGSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tconst prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';\n\n\t\t\tlet type = this.getType( member.type );\n\n\t\t\tif ( member.atomic ) {\n\n\t\t\t\ttype = 'atomic< ' + type + ' >';\n\n\t\t\t}\n\n\t\t\tsnippets.push( `\\t${ prefix + member.name } : ${ type }` );\n\n\t\t}\n\n\t\tif ( struct.output ) {\n\n\t\t\tsnippets.push( `\\t${ this.getBuiltins( 'output' ) }` );\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tlet result = '';\n\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length > 0 ) {\n\n\t\t\tconst snippets = [];\n\n\t\t\tfor ( const struct of structs ) {\n\n\t\t\t\tlet snippet = `struct ${ struct.name } {\\n`;\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t\tresult = '\\n' + snippets.join( '\\n\\n' ) + '\\n';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns a WGSL string representing a variable.\n\t *\n\t * @param {string} type - The variable's type.\n\t * @param {string} name - The variable's name.\n\t * @param {?number} [count=null] - The array length.\n\t * @return {string} The WGSL snippet that defines a variable.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\tlet snippet = `var ${ name } : `;\n\n\t\tif ( count !== null ) {\n\n\t\t\tsnippet += this.generateArrayDeclaration( type, count );\n\n\t\t} else {\n\n\t\t\tsnippet += this.getType( type );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tisCustomStruct( nodeUniform ) {\n\n\t\treturn nodeUniform.value.isStorageBufferAttribute && nodeUniform.node.structTypeNode !== null;\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = `texture_depth${multisampled}_2d`;\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\ttextureType = `texture_storage_2d<${ format }, ${ access }>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${ multisampled }_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.getNodeType( this ) );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tif ( this.isCustomStruct( uniform ) ) {\n\n\t\t\t\t\tbufferSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var<${ bufferAccessMode }> ${ uniform.name } : ${ bufferType };` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${ bufferType }>` : `${ bufferType }`;\n\t\t\t\t\tconst bufferSnippet = `\\tvalue : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >`;\n\n\t\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tthis.shaderStage = shaderStage;\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.getNodeType( this );\n\t\t\t\t\t\t\tstageData.structs += 'var<private> output : ' + stageData.returnType + ';';\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tthis.shaderStage = null;\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @param {?string} [output=null] - An optional output.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\t/**\n\t * Returns the WGSL type of the given node data type.\n\t *\n\t * @param {string} type - The node data type.\n\t * @return {string} The WGSL type.\n\t */\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @private\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t/**\n\t * Includes the given method name into the current\n\t * function node.\n\t *\n\t * @private\n\t * @param {string} name - The method name to include.\n\t * @return {CodeNode} The respective code node.\n\t */\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t/**\n\t * Returns a WGSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL compute shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @param {string} workgroupSize - The workgroup size.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${workgroupSize}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The WGSL snippet representing a struct.\n\t */\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct binding.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @param {string} access - The access.\n\t * @param {number} [binding=0] - The binding index.\n\t * @param {number} [group=0] - The group index.\n\t * @return {string} The WGSL snippet representing a struct binding.\n\t */\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${ binding } ) @group( ${ group } )\nvar<${access}> ${ name } : ${ structName };`;\n\n\t}\n\n}\n\nexport default WGSLNodeBuilder;\n"],
  "mappings": "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",
  "names": ["name", "type", "wgslTypeLib", "groupName"]
}
