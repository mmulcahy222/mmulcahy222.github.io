{
  "version": 3,
  "sources": ["../../three/src/textures/DataTexture.js", "../../three/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.js"],
  "sourcesContent": ["import { Texture } from './Texture.js';\nimport { NearestFilter } from '../constants.js';\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nexport { DataTexture };\n", "import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';\n\nimport NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';\nimport NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';\n\nimport { NodeSampledTexture, NodeSampledCubeTexture, NodeSampledTexture3D } from '../../common/nodes/NodeSampledTexture.js';\n\nimport { NoColorSpace, ByteType, ShortType, RGBAIntegerFormat, RGBIntegerFormat, RedIntegerFormat, RGIntegerFormat, UnsignedByteType, UnsignedIntType, UnsignedShortType, RedFormat, RGFormat, IntType, RGBFormat, RGBAFormat, FloatType } from '../../../constants.js';\nimport { DataTexture } from '../../../textures/DataTexture.js';\n\nconst glslMethods = {\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\n\n/**\n * A node builder targeting GLSL.\n *\n * This module generates GLSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new GLSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * An array that holds objects defining the varying and attribute data in\n\t\t * context of Transform Feedback.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.transforms = [];\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of used extensions.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage an Array of used builtins.\n\t\t *\n\t\t * @type {Object<string,Array<string>>}\n\t\t */\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Whether comparison in shader code are generated with methods or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.useComparisonMethod = true;\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved GLSL method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\t/**\n\t * Returns the output struct name. Not relevant for GLSL.\n\t *\n\t * @return {string}\n\t */\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The GLSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t */\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a GLSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.\n\t * @return {string} The property name.\n\t */\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true || texture.isData3DTexture === true ) {\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniform.type === 'texture3D' ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler3D ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a GLSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The GLSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tsnippets.push( `\\t${ member.type } ${ member.name };` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tconst outputSnippet = [];\n\n\t\tfor ( const struct of structs ) {\n\n\t\t\tif ( struct.output ) {\n\n\t\t\t\tfor ( const member of struct.members ) {\n\n\t\t\t\t\toutputSnippet.push( `layout( location = ${ member.index } ) out ${ member.type } ${ member.name };` );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet snippet = 'struct ' + struct.name + ' {\\n';\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};\\n';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( outputSnippet.length === 0 ) {\n\n\t\t\toutputSnippet.push( 'layout( location = 0 ) out vec4 fragColor;' );\n\n\t\t}\n\n\t\treturn '\\n' + outputSnippet.join( '\\n' ) + '\\n\\n' + snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\n\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat} out ${type} ${varying.name};\\n`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet += `${type} ${varying.name};\\n`; // generate variable (no varying required)\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat}in ${type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\t/**\n\t * Returns the draw index builtin.\n\t *\n\t * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.\n\t */\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\t/**\n\t * Enables the given extension.\n\t *\n\t * @param {string} name - The extension name.\n\t * @param {string} behavior - The extension behavior.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage.\n\t */\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the enabled extensions of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the enabled extensions.\n\t */\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `true` in context of GLSL.\n\t */\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\t/**\n\t * Registers a transform in context of Transform Feedback.\n\t *\n\t * @param {string} varyingName - The varying name.\n\t * @param {AttributeNode} attributeNode - The attribute node.\n\t */\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\t/**\n\t * Returns the transforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the transforms.\n\t */\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tsnippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns a GLSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The GLSL snippet representing a struct.\n\t */\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n// structs\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nexport default GLSLNodeBuilder;\n"],
  "mappings": "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",
  "names": []
}
